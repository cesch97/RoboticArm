RoboticArm
==========
The project is an implementation of a solver for the inverse kinematics problem of a robot. The project is focused on antropomorphic robots with 6 degrees of freedom but it can easily be extended to other types of robots. Compared to other traditional solvers that use the Jacobian matrix, this implementation is based on gradient descent. The idea is to write a function for the forward kinematics that takes the joint angles as input and returns the position of the end effector. Then, the inverse kinematics is solved by minimizing the distance between the desired position of the end effector and the position returned by the forward kinematics function. The implementation is done in JAX and the visulaization is done in matplotlib.

### Forward kinematics
The forward kinematics is implemented in the `forward_kinematics` function. The function takes the joint angles as input and returns the position of the end effector. The function is implemented in a way that it can be used with JAX to compute the gradient of the error with respect to the joint angles. The robot and its joints are modeled directly inside the function as a list of links. The base of the robot is assumed to be at the origin of the coordinate system and each link is defined by the 3D position of the end when the corresponding joint angle is 0.

### Inverse kinematics 
The inverse kinematics is implemented in the `inverse_kinematics` function. The function takes the desired position of the end effector and a set of initial joint angles as input and returns the joint angles that minimize the distance between the desired position and the position returned by the forward kinematics function. The function itearively updates the joint angles using the gradient of the distance with respect to the joint angles. The gradient is computed using JAX. The function also takes a learning rate as input to control the step size of the gradient descent. The process is repeated until the distance is below a certain threshold or a maximum number of iterations is reached.

### Results
JAX was mainly choosen because it uses JIT compilation and that allows the solver to work in realtime. The solver works extremely well for uncostrained robots (where each joint can take any position bewteen 0°-360°). I tried to introduce limits to the joints angle to account for the physical constraints of the robot but the solver doesn't work as well. I followed the approach of the barrier method where the distance between the desired position and the position returned by the forward kinematics function is multiplied by a penality factor that increases exponentially near the joint limits. It works for some configurations but the solver becomes unstable and different runs can results in different solutions. I think the problem is that the barrier term creates local minimums and gradient descent gets stuck in them. Probably a better design of the barrier term could solve the problem.

### Usage
To try the solver first you should model your robot in the `forward_kinematics` by defining the links and how the joint angles affect the position of the end effector. The you can use the `inverse_kinematics` function to find the joint angles and again use the `forward_kinematics` to calculate the position of the end effector and each link of the robot for visualization.  
A *program* can be a collections of points that the robot should reach: each point is composed of 6 values (x, y, z, roll, pitch, yaw) to define position and orientation of the end effector. The solver will try to reach each point in order. An example of a program is provided in `main.py`.